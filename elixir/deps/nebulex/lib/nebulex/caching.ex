defmodule Nebulex.Caching do
  @moduledoc """
  Caching utility macros.

  ## Shared Options

  All of the caching macros below accept the following options:

    * `:cache` - Defines what cache to use (required). Raises `ArgumentError`
      if the option is not present.

    * `:key` - Defines the cache access key (optional). If this option
      is not present, a default key is generated by hashing a two-elements
      tuple; first element is the function's name and the second one the
      list of arguments (e.g: `:erlang.phash2({name, args})`).

  ## Example

  Suppose we are using `Ecto` and we want to define some caching functions in
  the context `MyApp.Accounts`.

      defmodule MyApp.Accounts do
        import Ecto.Query
        import Nebulex.Caching

        alias MyApp.Accounts.User
        alias MyApp.Cache
        alias MyApp.Repo

        defcacheable get_user!(id), cache: Cache, key: {User, id} do
          Repo.get!(User, id)
        end

        defcacheable users_by_segment(segment \\\\ "standard"), cache: Cache do
          query = from(q in User, where: q.segment == ^segment)
          Repo.all(query)
        end

        defupdatable update_user!(%User{} = user, attrs), cache: Cache, key: {User, user.id} do
          user
          |> User.changeset(attrs)
          |> Repo.update!()
        end

        defevict delete_user(%User{} = user), cache: Cache, key: {User, user.id} do
          Repo.delete(user)
        end
      end
  """

  @doc """
  Defines a cacheable function with the given name `fun` and arguments `args`.

  The returned value by the code block is cached if it doesn't exist already
  in cache, otherwise, it is returned directly from cache and the code block
  is not executed.

  ## Options

  See the "Shared options" section at the module documentation.

  ## Examples

      defmodule MyApp.Example do
        import Nebulex.Caching

        defcacheable get_by_name(name, age), cache: MyApp.Cache, key: name do
          # your logic (maybe query the database)
        end

        defcacheable all(query), cache: MyApp.Cache do
          # your logic (maybe query the database)
        end
      end
  """
  defmacro defcacheable(fun, opts \\ [], do: block) do
    caching_action(:defcacheable, fun, opts, block)
  end

  @doc """
  Defines a function with cache eviction enabled on function completion
  (one or all values are removed on function completion).

  ## Options

    * `:all_entries` - Defines if all entries must be removed on function
      completion. Defaults to `false`.

  See the "Shared options" section at the module documentation.

  ## Examples

      defmodule MyApp.Example do
        import Nebulex.Caching

        defevict evict(name), cache: MyApp.Cache, key: name do
          # your logic (maybe update the database)
        end

        defevict evict_all(name), cache: MyApp.Cache, all_entries: true do
          # your logic (maybe update the database)
        end
      end
  """
  defmacro defevict(fun, opts \\ [], do: block) do
    caching_action(:defevict, fun, opts, block)
  end

  @doc """
  Defines an updatable caching function.

  The content of the cache is updated without interfering the function
  execution. That is, the method would always be executed and the result
  cached.

  The difference between `defcacheable/3` and `defupdatable/3` is that
  `defcacheable/3` will skip running the function (if the key exists in cache),
  whereas `defupdatable/3` will actually run the function and then put the
  result in the cache.

  ## Options

  See the "Shared options" section at the module documentation.

  ## Examples

      defmodule MyApp.Example do
        import Nebulex.Caching

        defupdatable update(name), cache: MyApp.Cache, key: name do
          # your logic (maybe update the database)
        end
      end
  """
  defmacro defupdatable(fun, opts \\ [], do: block) do
    caching_action(:defupdatable, fun, opts, block)
  end

  ## Private Functions

  defp caching_action(action, fun, opts, block) do
    cache =
      Keyword.get(opts, :cache) || raise ArgumentError, "expected cache: to be given as argument"

    {name, args} =
      case Macro.decompose_call(fun) do
        {_, _} = pair -> pair
        _ -> raise ArgumentError, "invalid syntax in #{action} #{Macro.to_string(fun)}"
      end

    as_args = build_as_args(args)
    key_var = Keyword.get(opts, :key)
    action_logic = action_logic(action, block, opts)

    quote do
      def unquote(name)(unquote_splicing(args)) do
        cache = unquote(cache)
        key = unquote(key_var) || :erlang.phash2({unquote(name), unquote(as_args)})
        unquote(action_logic)
      end
    end
  end

  defp action_logic(:defcacheable, block, _opts) do
    quote do
      if value = cache.get(key) do
        value
      else
        value = unquote(block)
        cache.set(key, value)
      end
    end
  end

  defp action_logic(:defevict, block, opts) do
    all_entries? = Keyword.get(opts, :all_entries, false)

    quote do
      if unquote(all_entries?),
        do: cache.flush(),
        else: cache.delete(key)

      unquote(block)
    end
  end

  defp action_logic(:defupdatable, block, _opts) do
    quote do
      value = unquote(block)
      cache.set(key, value)
    end
  end

  defp build_as_args(args) do
    for arg <- args, do: build_as_arg(arg)
  end

  defp build_as_arg({:\\, _, [arg, _default_arg]}), do: build_as_arg(arg)
  defp build_as_arg(arg), do: arg
end
